name: Conditional Makefile rebuild

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main


jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        if: github.event_name != 'pull_request'
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Checkout repository (PR)
        if: github.event_name == 'pull_request'
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref }}

      - uses: nrwl/nx-set-shas@v3
        id: last_successful_commit
        # if: github.event_name != 'pull_request'
        with:
          main-branch-name: 'main'
          workflow-id: 'update-makefile.yml'

      - name: Check for changes in PKGBUILD folders
        id: check_assets
        run: |
          commit_message=$(git log -1 --pretty=%B)
          if [[ $commit_message =~ "\#NoRebuild" ]]; then
            echo "Skipping PKGBUILDs check due to #NoRebuild or [No Rebuild] in commit message"
            echo "has_PKGBUILD_changes=false" >> $GITHUB_OUTPUT
            echo "has_AUR_lock_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          github_event_name=$(echo $GITHUB_EVENT_NAME | tr '[:upper:]' '[:lower:]') 
          # if [ $github_event_name = "pull_request" ] ; then 
          #   base_commit="main"
          # else 
            base_commit="${{ steps.last_successful_commit.outputs.base }}"
          # fi 
          echo "base_commit=$base_commit"

          git diff --name-only "${base_commit}..HEAD" -- 'PKGBUILDs/*/PKGBUILD' 'PKGBUILDs-extra/*/PKGBUILD' > /tmp/changed_PKGBUILDs.txt
          if grep -qE 'PKGBUILDs/|PKGBUILDs-extra/' /tmp/changed_PKGBUILDs.txt; then
            echo "PKGBUILDs changed. .SCRINFO will be updated in the matrix task..."
            pkgbuilds=()
            while IFS= read -r file; do
              pkgbuilds+=("$file")
              echo "Changed: $file"
            done < /tmp/changed_PKGBUILDs.txt
            echo "has_PKGBUILD_changes=true"
            echo "has_PKGBUILD_changes=true" >> $GITHUB_OUTPUT
            json=$(echo "${pkgbuilds[@]}" | jq -R . | jq --indent 0 -s .) # encode array as json
            echo "pkgbuilds=$json"
            echo "pkgbuilds=$json" >> $GITHUB_OUTPUT
          fi
          if git diff --name-only "${base_commit}..HEAD" -- aur.lock | grep -q 'aur.lock'; then
            echo "aur.lock changed."
            make aur-lock
            echo "has_AUR_lock_changes=true" >> $GITHUB_OUTPUT
          fi

      # A lot of ops in this workflow run on x86_64, so we optimize by caching the image
      - name: Cache makepkg image
        if: steps.check_assets.outputs.has_PKGBUILD_changes == 'true' || steps.check_assets.outputs.has_AUR_lock_changes == 'true'
        id: makepkg-cached
        uses: actions/cache@v3
        with:
            path: ~/image-cache/makepkg/amd64/
            key: makepkg-cached-amd64-${{ runner.os }}

      - if: (steps.check_assets.outputs.has_PKGBUILD_changes == 'true' || steps.check_assets.outputs.has_AUR_lock_changes == 'true') && steps.makepkg-cached.outputs.cache-hit != 'true'
        run: |
            docker pull ghcr.io/valorekhov/gha-makepkg-amd64:latest
            mkdir -p ~/image-cache/makepkg/amd64/
            docker save -o ~/image-cache/makepkg/amd64/image.tar ghcr.io/valorekhov/gha-makepkg-amd64:latest

      - if: steps.makepkg-cached.outputs.cache-hit == 'true'
        run: docker load -i ~/image-cache/makepkg/amd64/image.tar

      - name: "Check for changes in Makefile"
        if: steps.check_assets.outputs.has_PKGBUILD_changes == 'true' || steps.check_assets.outputs.has_AUR_lock_changes == 'true'
        # uses: ghcr.io/valorekhov/gha-makepkg-amd64:latest
        # with:
        #   operation: makefile-update
        #   packages: ${{ steps.check_assets.outputs.pkgbuilds }}
        run: | 
          docker run --rm  -v $PWD:/build \
            -e INPUT_OPERATION=makefile-update \
            -e INPUT_PACKAGES='${{ steps.check_assets.outputs.pkgbuilds }}' \
            ghcr.io/valorekhov/gha-makepkg-amd64:latest

      - name: Rebuild Makefile
        if: steps.check_assets.outputs.has_PKGBUILD_changes == 'true' || steps.check_assets.outputs.has_AUR_lock_changes == 'true'
        id: rebuild_makefile
        run: ./tools/generate-makefile.ps1 -SkipSrcInfoCheck
        shell: pwsh

      - name: Commit changes
        id: commit_changes
        if: steps.check_assets.outputs.has_PKGBUILD_changes == 'true' || steps.check_assets.outputs.has_AUR_lock_changes == 'true'
        run: |
          git config --local user.email "ovos-arch-buildbot@noemail.local"
          git config --local user.name "OVOS Arch BuildBot"
          git add .
          git diff-index --quiet HEAD || git commit -m "Update Makefile"
          git push

          # Update the last successful commit hash
          echo "current_commit=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "current_commit=$(git rev-parse HEAD)"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    outputs:
      has_PKGBUILD_changes: ${{ steps.check_assets.outputs.has_PKGBUILD_changes }}
      has_AUR_lock_changes: ${{ steps.check_assets.outputs.has_AUR_lock_changes }}
      pkgbuilds: ${{ steps.check_assets.outputs.pkgbuilds }}
      commit_hash: ${{ steps.commit_changes.outputs.current_commit }}

  # Because running QEMU builds on GitHub Actions is slow as molasses AND because the project's
  # python packages are predominantly built for the `any` architecture, we will first build
  # the x86_64 target and then distribute any `any` packages to the other architectures. 
  # This stage will filter out `any` packages and will pass down native packages to the next stage(s)
  package-build-amd64:
    needs: check
    if: needs.check.outputs.has_PKGBUILD_changes == 'true'
    runs-on: ubuntu-latest
    name: Build `x86_64` native and `any` arch packages
    steps:
    - name: "Checkout repository"
      uses: actions/checkout@v3
      with:
        fetch-depth: 1
        ref: ${{ needs.check.outputs.commit_hash }}

    - name: "Download repo from Azure Blob Storage"
      if: false && needs.check.outputs.has_PKGBUILD_changes == 'true'
      run: |
        archs=("x86_64" "aarch64" "armv7h")
        for arch in "${archs[@]}"
        do
            echo "Downloading repo DB for $arch..."
            mkdir -p .repo/"$arch"
            wget "https://ovosarchlinuxpkgs.blob.core.windows.net/ovos-arch/$arch/ovos-arch.db.tar.gz" -O .repo/"$arch"/ovos-arch.db.tar.gz
        done        

    - name: Cache makepkg image
      id: makepkg-cached
      uses: actions/cache@v3
      with:
          path: ~/image-cache/makepkg/amd64/
          key: makepkg-cached-amd64-${{ runner.os }}

    - if: steps.makepkg-cached.outputs.cache-hit != 'true'
      run: |
          docker pull ghcr.io/valorekhov/gha-makepkg-amd64:latest
          mkdir -p ~/image-cache/makepkg/amd64/
          docker save -o ~/image-cache/makepkg/amd64/image.tar ghcr.io/valorekhov/gha-makepkg-amd64:latest

    - if: steps.makepkg-cached.outputs.cache-hit == 'true'
      run: docker load -i ~/image-cache/makepkg/amd64/image.tar

    - name: "Build on x86_64"
      # uses: ghcr.io/valorekhov/gha-makepkg-amd64:latest
      # with:
      #   operation: repo-build
      #   packages: ${{ needs.check.outputs.pkgbuilds }}
      #   repourl: https://ovosarchlinuxpkgs.blob.core.windows.net/ovos-arch
      run: | 
        docker run --rm  -v $PWD:/build \
          -e INPUT_OPERATION=repo-build \
          -e INPUT_PACKAGES='${{ needs.check.outputs.pkgbuilds }}' \
          -e INPUT_REPOURL='https://ovosarchlinuxpkgs.blob.core.windows.net/ovos-arch' \
          ghcr.io/valorekhov/gha-makepkg-amd64:latest

    - name: "Identifying prepared arch packages"
      id: identify_available_packages
      if: github.event_name != 'pull_request'
      run: |
        archs=("x86_64" "aarch64" "armv7h")
        out_archs=()
        for arch in "${archs[@]}"
        do
          if ls ".repo/$arch/"*.pkg.tar.* 1> /dev/null 2>&1 ; then
            out_archs+=("$arch")
          fi
        done  
        echo "upload_archs=${out_archs[@]}" >> $GITHUB_OUTPUT

    - name: "Upload ${{ steps.identify_available_packages.outputs.upload_archs }} packages to Azure Blob Storage"
      if: steps.identify_available_packages.outputs.upload_archs != ''
      uses: azure/CLI@v1
      with:
        azcliversion: 2.50.0
        inlineScript: |
          IFS=' ' read -ra archs <<< "${{ steps.identify_available_packages.outputs.upload_archs }}"
          for arch in "${archs[@]}"
          do
            az storage blob upload-batch --account-name ovosarchlinuxpkgs --destination ovos-arch --destination-path $arch --source .repo/$arch --pattern "ovos-arch.db*" --content-encoding "gzip" --overwrite  
            az storage blob upload-batch --account-name ovosarchlinuxpkgs --destination ovos-arch --destination-path $arch --source .repo/$arch --pattern "*.pkg.tar.*" --content-encoding "gzip" --overwrite 
          done 
      env:
        AZURE_STORAGE_KEY: "${{ secrets.AZURE_STORAGE_KEY }}"

    # At this point the .repo/aarch64/ folder will possibly contain -any.pkg.tar.{zst,xz} files
    # We need to filter out the -any packages from the `needs.check.outputs.pkgbuilds` array
    # and pass down the native packages to the next stage. 
    # The pkgbuilds string contains entries in the format PKGBUILDs{,-extra}/<package_name>/PKGUILD 
    # encoded as a JSON array.
    # We iterate over -any.pkg.tar.{zst,xz} files extracting <package_name>, which ends before
    # the third dash counting from the end of the filename.
    - name: "Select native ARM packages to build"
      id: select_native_arm_packages
      run: |  
        archs=("aarch64" "armv7h")
        printf "{" > /tmp/pkgbuilds.json
        for arch in "${archs[@]}"
        do
          native_pkgbuilds=()
          original_pkgbuilds=($(echo '${{ needs.check.outputs.pkgbuilds }}' | jq -r '.[]'))
          echo "original_pkgbuilds='${original_pkgbuilds[@]}'"
          pushd ".repo/$arch/"
          pkgfiles=( *-any.pkg.tar.* )
          if (( ${#pkgfiles[@]} )); then
            echo "pkgfiles='${pkgfiles[@]}'"
            for pkg in $pkgfiles ; do
              echo "pkg=$pkg"
              pkgname=$(echo $pkg | rev | cut -d'-' -f4- | rev)
              echo "pkgname=$pkgname"
              for entry in $original_pkgbuilds ; do
                echo "entry=$entry, pkgname=$pkgname"
                if [[ $entry == *"/$pkgname/"* ]]; then
                  echo "$entry has already been built for ARM, skipping..."
                else
                  native_pkgbuilds+=($entry)
                fi
              done
            done
          else
            echo "Did not find any package files..."
          fi
          popd
          # echo "pkgbuilds_$arch=${native_pkgbuilds[@]}"
          # echo "pkgbuilds_$arch=${native_pkgbuilds[@]}" >> $GITHUB_OUTPUT
          printf "\"$arch\":" >> /tmp/pkgbuilds.json
          jq -j --compact-output --null-input '$ARGS.positional' --args -- "${native_pkgbuilds[@]}" | tr -d '\n' >> /tmp/pkgbuilds.json
          printf "," >> /tmp/pkgbuilds.json
        done
        printf "\"_foo\":[]}" >> /tmp/pkgbuilds.json
        json=$(cat /tmp/pkgbuilds.json)
        echo "pkgbuilds=$json"
        echo "pkgbuilds=$json" >> $GITHUB_OUTPUT

    - name: "Select ARM matrix archs" 
      id: select_arm_matrix_archs
      run: |
        [array]$arr=Get-Content -Path /tmp/pkgbuilds.json -Raw | ConvertFrom-Json | ForEach-Object {
           $_.psobject.Properties | Where-Object { -not $_.Name.StartsWith('_') -and $_.Value.Count -gt 0 } | %{ $_.Name }
        }
        Write-Host $arr
        $json = ConvertTo-Json $arr -Compress
        Write-Host "archs=$json"
        "archs=$json" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
      shell: pwsh

    outputs:
      pkgbuilds: ${{ steps.select_native_arm_packages.outputs.pkgbuilds }}
      matrix_arm_archs: ${{ steps.select_arm_matrix_archs.outputs.archs }}

  package-build-arm:
    needs: 
      - check
      - package-build-amd64
    runs-on: ubuntu-latest
    name: Build ARM packages
    strategy:
      matrix:
        arch: ${{ fromJson(needs.package-build-amd64.outputs.matrix_arm_archs) }}
    steps:
    - name: "Checkout repository"
      uses: actions/checkout@v3
      with:
        fetch-depth: 1
        ref: ${{ needs.check.outputs.commit_hash }}

    - name: "Download repo from Azure Blob Storage"
      run: |
        echo "Downloading repo DB..."
        mkdir -p .repo/${{ matrix.arch }}        
        wget https://ovosarchlinuxpkgs.blob.core.windows.net/ovos-arch/${{ matrix.arch }}/ovos-arch.db.tar.gz -O .repo/${{ matrix.arch }}/ovos-arch.db.tar.gz

    - name: Remap ArchLinux arch to docker arch
      id: arch_remap
      run: |
        case '${{ matrix.arch }}' in
          aarch64)
            echo "docker_arch=arm64v8" >> $GITHUB_OUTPUT
            ;;
          armv7h)
            export "docker_arch=arm32v7" >> $GITHUB_OUTPUT
            ;;
        esac
        
        echo "Packages to build for ${{ matrix.arch }}:"
        echo "${{ toJSON( fromJSON(needs.package-build-amd64.outputs.pkgbuilds)[matrix.arch] ) }}"

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v2
      with:
        platforms: ${{ steps.arch_remap.outputs.docker_arch }}
         
    - name: "Build on ${{ matrix.arch }}"
      # uses: ghcr.io/valorekhov/gha-makepkg-${{ steps.arch_remap.outputs.docker_arch }}:latest
      # with:
      #   operation: repo-build
      #   packages: ${{ needs.package-build-amd64.outputs['pkgbuilds_' + matrix.arch] }}
      #   repourl: https://ovosarchlinuxpkgs.blob.core.windows.net/ovos-arch
      run: | 
        docker run --rm -v $PWD:/build \
          -e INPUT_OPERATION=repo-build \
          -e INPUT_PACKAGES='${{ toJSON( fromJSON(needs.package-build-amd64.outputs.pkgbuilds)[matrix.arch] ) }}' \
          -e INPUT_REPOURL=https://ovosarchlinuxpkgs.blob.core.windows.net/ovos-arch \
          ghcr.io/valorekhov/gha-makepkg-${{ steps.arch_remap.outputs.docker_arch }}:latest

    - name: "Preparing native ${{ matrix.arch }} packages"
      id: identify_available_packages
      if: github.event_name != 'pull_request'
      run: |
        if ls .repo/${{ matrix.arch }}/*.pkg.tar.* 1> /dev/null 2>&1 ; then
          echo "upload=true"
          echo "upload=true" >> $GITHUB_OUTPUT
        fi

    - name: "Upload ${{ matrix.arch }} native packages to Azure Blob Storage"
      if: steps.identify_available_packages.outputs.upload == 'true'
      uses: azure/CLI@v1
      with:
        azcliversion: 2.50.0
        inlineScript: |
          az storage blob upload-batch --account-name ovosarchlinuxpkgs --destination ovos-arch --destination-path ${{ matrix.arch }} --source .repo/${{ matrix.arch }} --pattern "ovos-arch.db*" --content-encoding "gzip" --overwrite 
          az storage blob upload-batch --account-name ovosarchlinuxpkgs --destination ovos-arch --destination-path ${{ matrix.arch }} --source .repo/${{ matrix.arch }} --pattern "*.pkg.tar.*" --content-encoding "gzip" --overwrite 
      env:
        AZURE_STORAGE_KEY: "${{ secrets.AZURE_STORAGE_KEY }}"